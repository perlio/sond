/*
zond (zond_dbase.c) - Akten, Beweisstücke, Unterlagen
Copyright (C) 2022  pelo america

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

#include "zond_dbase.h"

#include <glib.h>
#include <glib/gstdio.h>
#include <sqlite3.h>
#include <gtk/gtk.h>

#include "../misc.h"

typedef enum
{
    PROP_PATH = 1,
    PROP_DBASE,
    N_PROPERTIES
} ZondDBaseProperty;

typedef struct
{
    gchar* path;
    sqlite3* dbase;
} ZondDBasePrivate;

G_DEFINE_TYPE_WITH_PRIVATE(ZondDBase, zond_dbase, G_TYPE_OBJECT)


static void
zond_dbase_set_property (GObject      *object,
                          guint         property_id,
                          const GValue *value,
                          GParamSpec   *pspec)
{
    ZondDBase* self = ZOND_DBASE(object);
    ZondDBasePrivate* priv = zond_dbase_get_instance_private( self );

    switch ((ZondDBaseProperty) property_id)
    {
        case PROP_PATH:
          priv->path = g_strdup( g_value_get_string(value) );
          break;

        case PROP_DBASE:
          priv->dbase = g_value_get_pointer(value);
          break;

        default:
          /* We don't have any other property... */
          G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
          break;
    }
}


static void
zond_dbase_get_property (GObject    *object,
                          guint       property_id,
                          GValue     *value,
                          GParamSpec *pspec)
{
    ZondDBase* self = ZOND_DBASE(object);
    ZondDBasePrivate* priv = zond_dbase_get_instance_private( self );

    switch ((ZondDBaseProperty) property_id)
    {
        case PROP_PATH:
                g_value_set_string( value, priv->path );
                break;

        case PROP_DBASE:
                g_value_set_pointer( value, priv->dbase );
                break;

        default:
                /* We don't have any other property... */
                G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
                break;
    }
}


static void
zond_dbase_finalize_stmts( sqlite3* db)
{
    sqlite3_stmt* stmt = NULL;

    while ( (stmt = sqlite3_next_stmt( db, NULL )) ) sqlite3_finalize( stmt );

    return;
}


static void
zond_dbase_finalize( GObject* self )
{
    ZondDBasePrivate* priv = zond_dbase_get_instance_private( ZOND_DBASE(self) );

    zond_dbase_finalize_stmts( priv->dbase);
    sqlite3_close( priv->dbase );

    g_free( priv->path );

    G_OBJECT_CLASS(zond_dbase_parent_class)->finalize( self );

    return;
}


static void
zond_dbase_class_init( ZondDBaseClass* klass )
{
    GParamSpec *obj_properties[N_PROPERTIES] = { NULL, };

    GObjectClass *object_class = G_OBJECT_CLASS(klass);

    object_class->finalize = zond_dbase_finalize;

    object_class->set_property = zond_dbase_set_property;
    object_class->get_property = zond_dbase_get_property;

    obj_properties[PROP_PATH] =
            g_param_spec_string( "path",
                                 "gchar*",
                                 "Pfad zur Datei.",
                                 NULL,
                                  G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE);

    obj_properties[PROP_DBASE] =
            g_param_spec_pointer( "dbase",
                                 "sqlite3*",
                                 "Datenbankverbindung.",
                                  G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE );

    g_object_class_install_properties(object_class,
                                      N_PROPERTIES,
                                      obj_properties);

    return;
}


static void
zond_dbase_init( ZondDBase* self )
{
//    ZondDBasePrivate* priv = zond_dbase_get_instance_private( self );

    return;
}


static gint
zond_dbase_create_db( sqlite3* db, gchar** errmsg )
{
    gchar* errmsg_ii = NULL;
    gchar* sql = NULL;
    gint rc = 0;

    //Tabellenstruktur erstellen
    sql = //Haupttabelle
            "DROP TABLE IF EXISTS fundstelle;"
            "DROP TABLE IF EXISTS baum; "

            //Hilfstabelle "dateien"
            //hier werden angebundene Dateien erfaßt
            "CREATE TABLE fundstelle ("
            "ID INTEGER PRIMARY KEY, "
            "rel_path VARCHAR(200),"
            "par1 INTEGER, "
            "par2 INTEGER, "
            "par3 INTEGER, "
            "par4 INTEGER "
            "); "

            "CREATE TABLE baum ("
                "node_id INTEGER PRIMARY KEY,"
                "parent_id INTEGER NOT NULL,"
                "older_sibling_id INTEGER NOT NULL,"
                "icon_name VARCHAR(50),"
                "node_text VARCHAR(200), "
                "text TEXT, "
                "ref INTEGER, "
                "type INTEGER, " //
                "FOREIGN KEY (parent_id) REFERENCES baum (node_id) "
                "ON DELETE CASCADE ON UPDATE CASCADE, "
                "FOREIGN KEY (older_sibling_id) REFERENCES baum (node_id) "
                "ON DELETE CASCADE ON UPDATE CASCADE "
            "); "

<<<<<<< HEAD
            "INSERT INTO baum (node_id, parent_id, older_sibling_id, "
            "node_text) VALUES (0, 0, 0, '"ZOND_DBASE_VERSION"'), "
            "(1, 0, 0, 'baum_inhalt'), (2, 0, 1, 'baum_auswertung');";
=======
            "INSERT INTO baum_inhalt (node_id, parent_id, older_sibling_id, "
            "node_text) VALUES (0, 0, 0, '"ZOND_DBASE_VERSION"');"

            //Hilfstabelle "dateien"
            //hier werden angebundene Dateien erfaßt
            "CREATE TABLE dateien ("
            "rel_path VARCHAR(200) PRIMARY KEY,"
            "node_id INTEGER NOT NULL, "
            "FOREIGN KEY (node_id) REFERENCES baum_inhalt (node_id) "
            "ON DELETE CASCADE ON UPDATE CASCADE);"

            //Hilfstabelle "ziele"
            //hier werden Anbindungen an Dateien mit Zusatzinfo abgelegt
            "CREATE TABLE ziele ("
            "ziel_id_von VARCHAR(50), "
            "index_von INTEGER, "
            "ziel_id_bis VARCHAR(50), "
            "index_bis INTEGER, "
            "rel_path VARCHAR(200) NOT NULL, "
            "node_id INTEGER NOT NULL, "
            "PRIMARY KEY (ziel_id_von, index_von, ziel_id_bis, index_bis), "
            "FOREIGN KEY (rel_path) REFERENCES dateien (rel_path) "
            "ON DELETE CASCADE ON UPDATE CASCADE,"
            "FOREIGN KEY (node_id) REFERENCES baum_inhalt (node_id) "
            "ON DELETE CASCADE ON UPDATE CASCADE );"

            //Auswertungs-Baum
            "CREATE TABLE baum_auswertung ( "
            "node_id INTEGER PRIMARY KEY,"
            "parent_id INTEGER NOT NULL,"
            "older_sibling_id INTEGER NOT NULL,"
            "icon_name VARCHAR(50),"
            "node_text VARCHAR(200),"
            "text VARCHAR, "
            "ref_id INTEGER NULL DEFAULT NULL,"
            "FOREIGN KEY (parent_id) REFERENCES baum_auswertung (node_id) "
            "ON DELETE CASCADE ON UPDATE CASCADE, "
            "FOREIGN KEY (older_sibling_id) REFERENCES baum_auswertung (node_id) "
            "ON DELETE CASCADE ON UPDATE CASCADE, "
            "FOREIGN KEY (ref_id) REFERENCES baum_inhalt (node_id) "
            "ON DELETE RESTRICT ON UPDATE RESTRICT );"

            "INSERT INTO baum_auswertung (node_id, parent_id, older_sibling_id) "
            "VALUES (0, 0, 0); " //mit eingang

            "CREATE TABLE links ( "
            "ID INTEGER PRIMARY KEY AUTOINCREMENT, " //order of appe...
            "baum_id INTEGER, "
            "node_id INTEGER, "
            "projekt_target VARCHAR (200), "
            "baum_id_target INTEGER, "
            "node_id_target INTEGER "
            " ); "

            "CREATE TRIGGER delete_links_baum_inhalt_trigger BEFORE DELETE ON baum_inhalt "
            "WHEN old.node_id=(SELECT node_id FROM links WHERE node_id=old.node_id AND baum_id=1) "
            "BEGIN "
            "DELETE FROM links WHERE node_id=old.node_id AND baum_id=1; "
            "END; "

            "CREATE TRIGGER delete_links_baum_auswertung_trigger BEFORE DELETE ON baum_auswertung "
            "WHEN old.node_id=(SELECT node_id FROM links WHERE node_id=old.node_id AND baum_id=2) "
            "BEGIN "
            "DELETE FROM links WHERE node_id=old.node_id AND baum_id=2; "
            "END; "
            ;
>>>>>>> 1dc3db5 (links angeklemmt; BugFix Parameter zond_tree_store)

    rc = sqlite3_exec( db, sql, NULL, NULL, &errmsg_ii );
    if ( rc != SQLITE_OK )
    {
        if ( errmsg ) *errmsg = g_strconcat( "Bei Aufruf sqlite3_exec\nsql: ",
                sql, "\nresult code: ", sqlite3_errstr( rc ), "\nerrmsg: ",
                errmsg_ii, NULL );
        sqlite3_free( errmsg_ii );

        return -1;
    }

    return 0;
}


//v0.7: in Tabellen baum_inhalt und baum_auswertung Spalte icon_id statt icon_name in v0.8
static gint
zond_dbase_convert_from_v0_7( sqlite3* db_convert, gchar** errmsg )
{
    gint rc = 0;
    gchar* errmsg_ii = NULL;

    gchar* sql = "INSERT INTO main.baum_inhalt "
                    "SELECT node_id, parent_id, older_sibling_id, "
                            "CASE icon_id "
                            "WHEN 0 THEN 'dialog-error' "
                            "WHEN 1 THEN 'emblem-new' "
                            "WHEN 2 THEN 'folder' "
                            "WHEN 3 THEN 'document-open' "
                            "WHEN 4 THEN 'pdf' "
                            "WHEN 5 THEN 'anbindung' "
                            "WHEN 6 THEN 'akte' "
                            "WHEN 7 THEN 'application-x-executable' "
                            "WHEN 8 THEN 'text-x-generic' "
                            "WHEN 9 THEN 'x-office-document' "
                            "WHEN 10 THEN 'x-office-presentation' "
                            "WHEN 11 THEN 'x-office-spreadsheet' "
                            "WHEN 12 THEN 'emblem-photo' "
                            "WHEN 13 THEN 'video-x-generic' "
                            "WHEN 14 THEN 'audio-x-generic' "
                            "WHEN 15 THEN 'mail-unread' "
                            "WHEN 16 THEN 'emblem-web' "
                            "WHEN 25 THEN 'system-log-out' "
                            "WHEN 26 THEN 'mark-location' "
                            "WHEN 27 THEN 'phone' "
                            "WHEN 28 THEN 'emblem-important' "
                            "WHEN 29 THEN 'camera-web' "
                            "WHEN 30 THEN 'media-optical' "
                            "WHEN 31 THEN 'user-info' "
                            "WHEN 32 THEN 'system-users' "
                            "WHEN 33 THEN 'orange' "
                            "WHEN 34 THEN 'blau' "
                            "WHEN 35 THEN 'rot' "
                            "WHEN 36 THEN 'gruen' "
                            "WHEN 37 THEN 'tuerkis' "
                            "WHEN 38 THEN 'magenta' "
                            "ELSE 'process-stop' "
                            "END, "
                        "node_text FROM old.baum_inhalt WHERE node_id!=0; "
            "INSERT INTO main.dateien SELECT uri, node_id FROM old.dateien; "
            "INSERT INTO main.ziele SELECT ziel_id_von, index_von, ziel_id_bis, index_bis, "
            "(SELECT uri FROM old.dateien WHERE datei_id=old.ziele.datei_id), "
            "node_id FROM old.ziele; "
            "INSERT INTO main.baum_auswertung "
                    "SELECT node_id, parent_id, older_sibling_id, "
                            "CASE icon_id "
                            "WHEN 0 THEN 'dialog-error' "
                            "WHEN 1 THEN 'emblem-new' "
                            "WHEN 2 THEN 'folder' "
                            "WHEN 3 THEN 'document-open' "
                            "WHEN 4 THEN 'pdf' "
                            "WHEN 5 THEN 'anbindung' "
                            "WHEN 6 THEN 'akte' "
                            "WHEN 7 THEN 'application-x-executable' "
                            "WHEN 8 THEN 'text-x-generic' "
                            "WHEN 9 THEN 'x-office-document' "
                            "WHEN 10 THEN 'x-office-presentation' "
                            "WHEN 11 THEN 'x-office-spreadsheet' "
                            "WHEN 12 THEN 'emblem-photo' "
                            "WHEN 13 THEN 'video-x-generic' "
                            "WHEN 14 THEN 'audio-x-generic' "
                            "WHEN 15 THEN 'mail-unread' "
                            "WHEN 16 THEN 'emblem-web' "
                            "WHEN 25 THEN 'system-log-out' "
                            "WHEN 26 THEN 'mark-location' "
                            "WHEN 27 THEN 'phone' "
                            "WHEN 28 THEN 'emblem-important' "
                            "WHEN 29 THEN 'camera-web' "
                            "WHEN 30 THEN 'media-optical' "
                            "WHEN 31 THEN 'user-info' "
                            "WHEN 32 THEN 'system-users' "
                            "WHEN 33 THEN 'orange' "
                            "WHEN 34 THEN 'blau' "
                            "WHEN 35 THEN 'rot' "
                            "WHEN 36 THEN 'gruen' "
                            "WHEN 37 THEN 'tuerkis' "
                            "WHEN 38 THEN 'magenta' "
                            "ELSE 'process-stop' "
                            "END, "
                        "node_text, text, ref_id FROM old.baum_auswertung WHERE node_id!=0; ";

    rc = sqlite3_exec( db_convert, sql, NULL, NULL, &errmsg_ii );
    if ( rc != SQLITE_OK )
    {
        if ( errmsg ) *errmsg = g_strconcat( "Bei Aufruf sqlite3_exec:\n"
                "result code: ", sqlite3_errstr( rc ), "\nerrmsg: ",
                errmsg_ii, NULL );
        sqlite3_free( errmsg_ii );

        return -1;
    }

    return 0;
}


//v0.8 Tabellen eingang und eingang_rel_path fehlen ggü. v0.9
static gint
zond_dbase_convert_from_v0_8( sqlite3* db_convert, gchar** errmsg )
{
    gint rc = 0;

    gchar* sql =
            "INSERT INTO baum_inhalt SELECT node_id, parent_id, older_sibling_id, "
                    "icon_name, node_text FROM old.baum_inhalt WHERE node_id != 0; "
            "INSERT INTO baum_auswertung SELECT * FROM old.baum_auswertung WHERE node_id != 0; "
            "INSERT INTO dateien SELECT * FROM old.dateien; "
            "INSERT Into ziele SELECT * FROM old.ziele; ";

    rc = sqlite3_exec( db_convert, sql, NULL, NULL, errmsg );
    if ( rc != SQLITE_OK )
    {
        if ( errmsg ) *errmsg = add_string( g_strdup( "Bei Aufruf sqlite3_exec:\n" ),
                *errmsg );

        return -1;
    }

    return 0;
}


//v0.9 Tabellen eingang und eingang_rel_path fehlen ggü. v0.8
static gint
zond_dbase_convert_from_v0_9( sqlite3* db_convert, gchar** errmsg )
{
    gint rc = 0;

    gchar* sql =
            "INSERT INTO baum_inhalt SELECT node_id, parent_id, older_sibling_id, "
                    "icon_name, node_text FROM old.baum_inhalt WHERE node_id != 0; "
            "INSERT INTO baum_auswertung SELECT * FROM old.baum_auswertung WHERE node_id != 0; "
            "INSERT INTO dateien SELECT * FROM old.dateien; "
            "INSERT Into ziele SELECT * FROM old.ziele; "
            "INSERT INTO eingang SELECT * FROM old.eingang; "
            "INSERT INTO eingang_rel_path SELECT * FROM old.eingang_rel_path; "
            ;

    rc = sqlite3_exec( db_convert, sql, NULL, NULL, errmsg );
    if ( rc != SQLITE_OK )
    {
        if ( errmsg ) *errmsg = add_string( g_strdup( "Bei Aufruf sqlite3_exec:\n" ),
                *errmsg );

        return -1;
    }

    return 0;
}


static gint
zond_dbase_convert_to_actual_version( const gchar* path, gchar* v_string,
        gchar** errmsg ) //eingang hinzugefügt
{
    gint rc = 0;
    sqlite3* db = NULL;
    gchar* sql = NULL;
    gchar* path_old = NULL;
    sqlite3_stmt* stmt = NULL;
    gchar* path_new = NULL;

    path_new = g_strconcat( path, ".tmp", NULL );
    rc = sqlite3_open( path_new, &db);
    if ( rc != SQLITE_OK )
    {
        if ( errmsg ) *errmsg = g_strconcat( "Bei Aufruf "
                "sqlite3_open:\n", sqlite3_errmsg( db ), NULL );
        g_free( path_new );

        return -1;
    }

    if ( zond_dbase_create_db( db, errmsg ) )
    {
        sqlite3_close( db);
        g_free( path_new );

        ERROR_SOND( "zond_dbase_create_db" );
    }

    sql = g_strdup_printf( "ATTACH DATABASE '%s' AS old;", path );
    rc = sqlite3_exec( db, sql, NULL, NULL, errmsg );
    g_free( sql );
    if ( rc != SQLITE_OK )
    {
        if ( errmsg ) *errmsg = g_strconcat( "Bei Aufruf sqlite3_exec:\n"
                "result code: ", sqlite3_errstr( rc ), "\nerrmsg: ",
                *errmsg, NULL );
        sqlite3_close( db );
        g_free( path_new );

        return -1;
    }

    if ( !g_strcmp0( v_string , "v0.7" ) )
    {
        rc = zond_dbase_convert_from_v0_7( db, errmsg );
        if ( rc )
        {
            sqlite3_close( db );
            g_free( path_new );

            ERROR_SOND( "convert_from_v0_7" )
        }
    }
    else if ( !g_strcmp0( v_string , "v0.8" ) )
    {
        rc = zond_dbase_convert_from_v0_8( db, errmsg );
        if ( rc )
        {
            sqlite3_close( db );
            g_free( path_new );
            ERROR_SOND( "convert_from_v0_8" )
        }
    }
    else if ( !g_strcmp0( v_string , "v0.9" ) )
    {
        rc = zond_dbase_convert_from_v0_9( db, errmsg );
        if ( rc )
        {
            sqlite3_close( db );
            g_free( path_new );
            ERROR_S
        }
    }
    else
    {
        //Mitteilung, daß keine Versionsangabe
        if ( errmsg ) *errmsg = g_strdup( "Keine Version erkannt - ggf. händisch überprüfen" );
        sqlite3_close( db );
        g_free( path_new );

        return -1;
    }

    //updaten#
    sql = "UPDATE baum SET node_text = '"ZOND_DBASE_VERSION"' WHERE node_id = 0;";
    rc = sqlite3_prepare_v2( db, sql, -1, &stmt, NULL );
    if ( rc != SQLITE_OK )
    {
        if ( errmsg ) *errmsg = g_strconcat( "Bei Aufruf sqlite3_prepare_v2:\n",
                sqlite3_errstr( rc ), NULL );
        sqlite3_close( db );
        g_free( path_new );

        return -1;
    }

    rc = sqlite3_step( stmt );
    sqlite3_finalize( stmt );
    if ( rc != SQLITE_DONE )
    {
        sqlite3_close( db );
        g_free( path_new );
        if ( errmsg ) *errmsg = add_string( g_strconcat( "Bei Aufruf sqlite3_step:\n",
                sqlite3_errmsg( db ), NULL ), *errmsg );

        return -1;
    }

    sqlite3_close( db );

    path_old = g_strconcat( path, v_string, NULL );
    rc = g_rename( path, path_old);
    g_free( path_old );
    if ( rc )
    {
        if ( errmsg ) *errmsg = g_strconcat( "Bei Aufruf g_rename:\n",
                strerror( errno ), NULL );
        g_free( path_new );

        return -1;
    }

    rc = g_rename ( path_new, path );
    g_free( path_new );
    if ( rc )
    {
        if ( errmsg ) *errmsg = g_strconcat( "Bei Aufruf g_rename:\n",
                strerror( errno ), NULL );

        return -1;
    }

    return 0;
}


static gchar*
zond_dbase_get_version( sqlite3* db, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt* stmt = NULL;
    gchar* v_string = NULL;

    rc = sqlite3_prepare_v2( db, "SELECT node_text FROM baum WHERE node_id = 0;", -1, &stmt, NULL );
    if ( rc != SQLITE_OK )
    {
        if ( errmsg ) *errmsg = g_strconcat( "Bei Aufruf sqlite3_prepare_v2:\n",
                sqlite3_errstr( rc ), NULL );

        return NULL;
    }

    rc = sqlite3_step( stmt );
    if ( rc != SQLITE_ROW )
    {
        if ( errmsg ) *errmsg = add_string( g_strconcat( "Bei Aufruf sqlite3_step:\n",
                sqlite3_errmsg( db ), NULL ), *errmsg );
        sqlite3_finalize( stmt );

        return NULL;
    }

    v_string = g_strdup( (const gchar*) sqlite3_column_text( stmt, 0 ) );

    sqlite3_finalize( stmt );

    return v_string;
}


static gint
zond_dbase_open( const gchar* path, gboolean create_file, gboolean create, sqlite3** db, gchar** errmsg )
{
    gint rc = 0;

    rc = sqlite3_open_v2( path, db, SQLITE_OPEN_READWRITE |
            ((create_file || create) ? SQLITE_OPEN_CREATE : 0), NULL );
    if ( rc != SQLITE_OK ) //Datei nicht vorhanden und weder create_file noch file
    {
        sqlite3_close( *db );

        if ( errmsg ) *errmsg = g_strconcat( "Bei Aufruf sqlite3_open_v2:\n",
                sqlite3_errstr( rc ), NULL );

        return -1;
    }
    else if ( !(create_file || create) ) //Alt-Datei war vorhanden - Versions-Check
    {
        gchar* v_string = NULL;

        v_string = zond_dbase_get_version( *db, errmsg );
        if ( !v_string )
        {
            sqlite3_close( *db );
            ERROR_SOND( "zond_dbase_get_version" );
        }

        if ( g_strcmp0( v_string, ZOND_DBASE_VERSION ) ) //alte version
        {
            gint rc = 0;

            sqlite3_close( *db );

            rc = zond_dbase_convert_to_actual_version( path, v_string, errmsg );
            if ( rc ) ERROR_SOND( "zond_dbase_convert_to_actual_version" )
            else display_message( NULL, "Datei von ", v_string, " zu "ZOND_DBASE_VERSION
                    " konvertiert", NULL );

            rc = sqlite3_open_v2( path, db, SQLITE_OPEN_READWRITE, NULL );
            if ( rc ) ERROR_SOND( "sqlite3_open_v2" )
        }
    }
    else if ( create ) //Datenbank soll neu angelegt werden
    {
        gint rc = 0;

        //Abfrage, ob überschrieben werden soll, überflüssig - schon im filechooser
        rc = zond_dbase_create_db( *db, errmsg );
        if ( rc )
        {
            sqlite3_close( *db );
            ERROR_SOND( "zond_dbase_create_db" )
        }
    }

    rc = sqlite3_exec( *db, "PRAGMA foreign_keys = ON; PRAGMA case_sensitive_like "
            "= ON", NULL, NULL, errmsg );
    if ( rc != SQLITE_OK )
    {
        sqlite3_close( *db );
        ERROR_SOND( "sqlite3_exec (PRAGMA)" )
    }

    return 0;
}


gint
zond_dbase_new( const gchar* path, gboolean create_file, gboolean create,
        ZondDBase** zond_dbase, gchar** errmsg )
{
    gint rc = 0;
    sqlite3* db = NULL;

    g_return_val_if_fail( zond_dbase, -1 );

    rc = zond_dbase_open( path, create_file, create, &db, errmsg );
    if ( rc ) ERROR_SOND( "zond_dbase_open" )

    *zond_dbase = g_object_new( ZOND_TYPE_DBASE, "path", path, "dbase", db, NULL );

    return 0;
}


void
zond_dbase_close( ZondDBase* zond_dbase )
{
    g_object_unref( zond_dbase );

    return;
}


sqlite3*
zond_dbase_get_dbase( ZondDBase* zond_dbase )
{
    ZondDBasePrivate* priv = zond_dbase_get_instance_private( zond_dbase );

    return priv->dbase;
}


const gchar*
zond_dbase_get_path( ZondDBase* zond_dbase )
{
    ZondDBasePrivate* priv = zond_dbase_get_instance_private( zond_dbase );

    return priv->path;
}


gint
zond_dbase_backup( ZondDBase* src, ZondDBase* dst, gchar** errmsg )
{
    gint rc = 0;
    sqlite3* db_src = NULL;
    sqlite3* db_dst = NULL;
    sqlite3_backup* backup = NULL;

    db_src = zond_dbase_get_dbase( src );
    db_dst = zond_dbase_get_dbase( dst );

    //Datenbank öffnen
    backup = sqlite3_backup_init( db_dst, "main", db_src, "main" );
    if ( !backup )
    {
        if ( errmsg ) *errmsg = g_strconcat( "Bei Aufruf ", __func__,
                ":\nBei Aufruf sqlite3_backup_init\nresult code: ",
                sqlite3_errstr( sqlite3_errcode( db_dst ) ), "\n",
                sqlite3_errmsg( db_dst ), NULL);

        return -1;
    }
    rc = sqlite3_backup_step( backup, -1 );
    sqlite3_backup_finish( backup );
    if ( rc != SQLITE_DONE )
    {
        if ( errmsg && rc == SQLITE_NOTADB ) *errmsg = g_strdup( "Datei ist "
                "keine SQLITE-Datenbank" );
        else if ( errmsg ) *errmsg = g_strconcat( "Bei Aufruf ", __func__,
                "Bei Aufruf sqlite3_backup_step:\nresult code: ",
                sqlite3_errstr( rc ), "\n", sqlite3_errmsg( db_dst ), NULL );

        return -1;
    }

    return 0;
}


static gint
zond_dbase_prepare_stmts( ZondDBase* zond_dbase, gint num, const gchar** sql,
        sqlite3_stmt** stmt, gchar** errmsg )
{
    for ( gint i = 0; i < num; i++ )
    {
        gint rc = 0;

        ZondDBasePrivate* priv = zond_dbase_get_instance_private( zond_dbase );

        rc = sqlite3_prepare_v2( priv->dbase, sql[i], -1, &stmt[i], NULL );
        if ( rc != SQLITE_OK && errmsg )
        {
            //aufräumen
            for ( gint u = 0; u < i; u++ ) sqlite3_finalize( stmt[u] );
            ERROR_ZOND_DBASE( "sqlite3_prepare_v2" )
        }
    }

    return 0;
}


gint
zond_dbase_prepare( ZondDBase* zond_dbase, const gchar* func, const gchar** sql,
        gint num_stmts, sqlite3_stmt*** stmt, gchar** errmsg )
{
    if ( !(*stmt = g_object_get_data( G_OBJECT(zond_dbase), func )) )
    {
        gint rc = 0;

        *stmt = g_malloc0( sizeof( sqlite3_stmt* ) * num_stmts );

        rc = zond_dbase_prepare_stmts( zond_dbase, num_stmts, sql, *stmt, errmsg );
        if ( rc )
        {
            g_free( *stmt );
            ERROR_S
        }

        g_object_set_data_full( G_OBJECT(zond_dbase), func, *stmt, g_free );
    }

    for ( gint i = 0; i < num_stmts; i++ ) sqlite3_reset( (*stmt)[i] );

    return 0;
}


gint
zond_dbase_begin( ZondDBase* zond_dbase, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
            "BEGIN; "
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step" )

    return 0;
}


gint
zond_dbase_commit( ZondDBase* zond_dbase, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
            "COMMIT; "
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step" )

    return 0;
}


gint
zond_dbase_rollback( ZondDBase* zond_dbase, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
            "ROLLBACK; "
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step" )

    return 0;
}


gint
zond_dbase_insert_node( ZondDBase* zond_dbase, gint node_id, gboolean child,
        const gchar* icon_name, const gchar* node_text, const gchar* text, gint ref, gint type, gchar** errmsg )
{
    gint rc = 0;
    gint new_node_id = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
            "INSERT INTO baum "
            "(parent_id, older_sibling_id, icon_name, node_text, text, ref, type) "
            "VALUES ("
                "CASE ?1 " //child
                    "WHEN 0 THEN (SELECT parent_id FROM baum WHERE node_id=?2) "
                    "WHEN 1 THEN ?2 " //node_id
                "END, "
                "CASE ?1 "
                    "WHEN 0 THEN ?2 "
                    "WHEN 1 THEN 0 "
                "END, "
                "?3, " //icon
                "?4, " //node_text
                "?5, " //text
                "?6, " //ref
                "?7); ", //type

            "UPDATE baum SET older_sibling_id=last_insert_rowid() "
                "WHERE "
                    "parent_id=(SELECT parent_id FROM baum WHERE node_id=last_insert_rowid()) "
                "AND "
                    "older_sibling_id=(SELECT older_sibling_id FROM baum WHERE node_id=last_insert_rowid()) "
                "AND "
                    "node_id!=last_insert_rowid() "
                "AND "
                    "node_id!=0; ",

            "VALUES (last_insert_rowid()); " };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_SOND( "zond_dbase_prepare" )

    rc = sqlite3_bind_int( stmt[0], 1, child );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (child)" )

    rc = sqlite3_bind_int( stmt[0], 2, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_id)" )

    rc = sqlite3_bind_text( stmt[0], 3, icon_name, -1, NULL );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_text (icon_name)" )

    rc = sqlite3_bind_text( stmt[0], 4, node_text, -1, NULL );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_text (node_text)" )

    rc = sqlite3_bind_text( stmt[0], 5, text, -1, NULL );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_text (text)" )

    rc = sqlite3_bind_int( stmt[0], 6, ref );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (ref)" )

    rc = sqlite3_bind_int( stmt[0], 7, type );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (type)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step [0]" )

    rc = sqlite3_step( stmt[1] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step ([1])" )

    rc = sqlite3_step( stmt[2] );
    if ( rc != SQLITE_ROW ) ERROR_ZOND_DBASE( "sqlite3_step ([2])" )

    new_node_id = sqlite3_column_int( stmt[2], 0 );

    return new_node_id;
}


gint
zond_dbase_remove_node( ZondDBase* zond_dbase, gint node_id, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
            "UPDATE baum SET older_sibling_id=(SELECT older_sibling_id FROM baum "
            "WHERE node_id=?1) WHERE "
            "older_sibling_id=?1; ",

            "DELETE FROM baum WHERE node_id = ?1; " };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_SOND( "zond_dbase_prepare" )

    rc = sqlite3_bind_int( stmt[0], 1, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_id)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step [0]" )

    rc = sqlite3_bind_int( stmt[1], 1, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_id)" )

    rc = sqlite3_step( stmt[1] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step [1]" )

    return 0;
}

/*
gint
zond_dbase_copy_node( ZondDBase* zond_dbase, gint node_id_von,
        gint node_id_nach, gboolean child, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
            "INSERT INTO baum "
            "(parent_id, older_sibling_id, icon_name, node_text, text, ref, type) "
            "VALUES ("
                "CASE ?1 " //child
                    "WHEN 0 THEN (SELECT parent_id FROM baum WHERE node_id=?2) "
                    "WHEN 1 THEN ?2 " //node_id_nach
                "END, "
                "CASE ?1 " //older_sibling_id
                    "WHEN 0 THEN ?2 "
                    "WHEN 1 THEN 0 "
                "END, "
                "(SELECT icon FROM baum WHERE node_id=?3), " //node_id_von
                "(SELECT node_text FROM baum WHERE node_id=?3), "//node_text
                "(SELECT text FROM baum WHERE node_id=?3), " //node_id_von
                "(SELECT ref FROM baum WHERE node_id=?3), "//node_text
                "(SELECT type FROM baum WHERE node_id=?3) "//node_text
                "); ",

            "UPDATE baum SET "
                "older_sibling_id=last_insert_rowid() "
            "WHERE "
                "parent_id=(SELECT parent_id FROM baum WHERE node_id=last_insert_rowid()) "
            "AND "
                "older_sibling_id=(SELECT older_sibling_id FROM baum WHERE node_id=last_insert_rowid()) "
            "AND "
                "node_id!=last_insert_rowid() "
            "AND "
                "node_id!=0; " };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_SOND( "zond_dbase_prepare" )

    rc = sqlite3_bind_int( stmt[0], 1, child );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (child)" )

    rc = sqlite3_bind_int( stmt[0], 2, node_id_nach );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_id_nach)" )

    rc = sqlite3_bind_int( stmt[0], 3, node_id_von );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_id_von)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step [0/1]" )

    rc = sqlite3_step( stmt[1] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step ([2])" )

    return sqlite3_last_insert_rowid( zond_dbase_get_dbase( zond_dbase ) );
}
*/


gint
zond_dbase_get_node( ZondDBase* zond_dbase, gint node_id, gint* parent_id,
        gint* older_sibling_id, gchar** icon_name, gchar** node_text, gchar** text,
        gint* ref, gint* type,  gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
        //...
            "SELECT parent_id, older_sibling_id, icon_name, node_text, text, ref, type FROM baum WHERE node_id=?;",
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_SOND( "zond_dbase_prepare" )

    rc = sqlite3_bind_int( stmt[0], 1, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_id)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE && rc != SQLITE_ROW ) ERROR_ZOND_DBASE( "sqlite3_step" )

    if ( rc == SQLITE_ROW )
    {
        if ( parent_id ) *parent_id = sqlite3_column_int( stmt[0], 0 );
        if ( older_sibling_id ) *older_sibling_id = sqlite3_column_int( stmt[0], 1 );
        if ( icon_name ) *icon_name = g_strdup( (const gchar*) sqlite3_column_text( stmt[0], 2 ) );
        if ( node_text ) *node_text = g_strdup( (const gchar*) sqlite3_column_text( stmt[0], 3 ) );
        if ( text ) *text = g_strdup( (const gchar*) sqlite3_column_text( stmt[0], 4 ) );
        if ( ref ) *ref = sqlite3_column_int( stmt[0], 5 );
        if ( type ) *type = sqlite3_column_int( stmt[0], 6 );
    }
    else if ( rc == SQLITE_DONE ) return 1; //node_id nicht gefunden

    return 0;
}


static gint
_do_zond_dbase_copy_node( ZondDBase* zond_dbase, gint node_von,
        gint node_nach, gboolean kind, gchar** errmsg )
{
    gint rc = 0;
    gint new_node_id = 0;
    gchar* icon_name = NULL;
    gchar* node_text = NULL;
    gchar* text = NULL;
    gint ref = 0;
    gint type = 0;

    rc = zond_dbase_get_node( zond_dbase, node_von, NULL, NULL, &icon_name,
            &node_text, &text, &ref, &type, errmsg );
    if ( rc ) ERROR_S

    new_node_id = zond_dbase_insert_node( zond_dbase, node_nach, kind, icon_name,
            node_text, text, ref, type, errmsg );
    g_free( icon_name );
    g_free( node_text );
    g_free( text );
    if ( new_node_id == -1 ) ERROR_S

    return 0;
}


gint
zond_dbase_copy_node( ZondDBase* zond_dbase, gint node_von, gint node_nach,
        gboolean kind, gchar** errmsg )
{
    gint rc = 0;
    gint child_id = 0;
    gint new_node_id = 0;

    //wenn node_id_nach == 0 ist child egal, wird immer als kind eingesetzt
    new_node_id = _do_zond_dbase_copy_node( zond_dbase, node_von, node_nach,
            kind, errmsg );
    if ( new_node_id == -1 ) ERROR_S

    //Prüfen, ob Kindknoten vorhanden
    child_id = zond_dbase_get_first_child( zond_dbase, node_von, errmsg );
    if ( child_id < 0 ) ERROR_S
    if ( child_id > 0 )
    {
        gboolean child = TRUE;
        gint anchor_node = new_node_id;

        do
        {
            gint new_child_id = 0;

            new_child_id = zond_dbase_copy_node( zond_dbase, child_id,
                    anchor_node, child, errmsg );
            if ( rc == -1  ) ERROR_S

            anchor_node = new_child_id;
            child = FALSE;
        }
        while ( (child_id =
                zond_dbase_get_younger_sibling( zond_dbase, child_id, errmsg )) );
    }

    return new_node_id;
}


gint
zond_dbase_verschieben_knoten( ZondDBase* zond_dbase, gint node_id, gint new_parent_id,
        gint new_older_sibling_id, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
            "UPDATE baum SET older_sibling_id="
            "(SELECT older_sibling_id FROM baum WHERE node_id=?1)" //node_id
            "WHERE older_sibling_id=?1; ",

            "UPDATE baum SET older_sibling_id=?1 WHERE node_id=" //node_id
                "(SELECT node_id FROM baum WHERE parent_id=?2 AND older_sibling_id=?3); ", //new_parent_id/new_older_s_id

            "UPDATE baum SET parent_id=?1, older_sibling_id=?2 WHERE node_id=?3; " };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_SOND( "zond_dbase_prepare" )

    rc = sqlite3_bind_int( stmt[0], 1, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int [0]" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step [0]" )

    rc = sqlite3_bind_int( stmt[1], 1, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int [1]" )

    rc = sqlite3_bind_int( stmt[1], 2, new_parent_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int [1]" )

    rc = sqlite3_bind_int( stmt[1], 3, new_older_sibling_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int [1]" )

    rc = sqlite3_step( stmt[1] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step [2]" )

    rc = sqlite3_bind_int( stmt[2], 1, new_parent_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int [2]" )

    rc = sqlite3_bind_int( stmt[2], 2, new_older_sibling_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int [2]" )

    rc = sqlite3_bind_int( stmt[2], 3, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int [2]" )

    rc = sqlite3_step( stmt[2] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step [2]" )

    return 0;
}


/** gibt auch dann 0 zurück, wenn der Knoten gar nicht existiert   **/
gint
zond_dbase_update_node( ZondDBase* zond_dbase, gint node_id, const gchar* icon_name,
        const gchar* node_text, const gchar* text, gint ref, gint type,
        gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
/*  full_set_icon_id  */
            "UPDATE baum SET "
                "icon_name = CASE "
                    "WHEN ?2 = 0 THEN icon_name "
                    "ELSE ?2 "
                    "END, "
                "node_text = CASE "
                    "WHEN ?3 IS NULL THEN node_text "
                    "ELSE ?3 "
                    "END, "
                "text = CASE "
                    "WHEN ?4 IS NULL THEN text "
                    "ELSE ?4 "
                    "END, "
                "ref = CASE "
                    "WHEN ?5 = 0 THEN ref "
                    "ELSE ?5 "
                    "END, "
                "type = CASE "
                    "WHEN ?6 = 0 THEN type "
                    "ELSE ?6 "
                    "END "
                "WHERE node_id=?1;"
       };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_SOND( "zond_dbase_prepare" )

    rc = sqlite3_bind_int( stmt[0], 1, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_id)" )

    rc = sqlite3_bind_text( stmt[0], 2, icon_name, -1, NULL );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_text (icon_name)" )

    rc = sqlite3_bind_text( stmt[0], 3, node_text, -1, NULL );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_text)" )

    rc = sqlite3_bind_text( stmt[0], 4, text, -1, NULL );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (text)" )

    rc = sqlite3_bind_int( stmt[0], 5, ref );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (ref)" )

    rc = sqlite3_bind_int( stmt[0], 6, type );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (type)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step" )

    return 0;
}


gint
zond_dbase_get_younger_sibling( ZondDBase* zond_dbase, gint node_id, gchar** errmsg )
{
    gint rc = 0;
    gint younger_sibling_id = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
        //...
            "SELECT inhalt1.node_id, inhalt2.node_id FROM baum AS inhalt1 "
                "LEFT JOIN baum AS inhalt2 "
                "ON inhalt1.node_id = inhalt2.older_sibling_id "
                "WHERE inhalt1.node_id > 0 AND inhalt1.node_id = ?1;"
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_SOND( "zond_dbase_prepare" )

    rc = sqlite3_bind_int( stmt[0], 1, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_id)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE && rc != SQLITE_ROW ) ERROR_ZOND_DBASE( "sqlite3_step" )

    if ( rc == SQLITE_ROW ) younger_sibling_id =
            sqlite3_column_int( stmt[0], 1 );

    if ( rc == SQLITE_DONE )
    {
        if ( errmsg ) *errmsg = g_strdup( "node_id existiert nicht" );

        return -2;
    }

    return younger_sibling_id;
}


gint
zond_dbase_get_first_child( ZondDBase* zond_dbase, gint node_id, gchar** errmsg )
{
    gint rc = 0;
    gint first_child_id = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
        //...
            "SELECT inhalt1.node_id, inhalt2.node_id FROM baum AS inhalt1 "
                "LEFT JOIN baum AS inhalt2 "
                "ON inhalt1.node_id = inhalt2.parent_id AND inhalt2.older_sibling_id = 0 "
                    "AND inhalt2.node_id != 0 "
                "WHERE inhalt1.node_id = ?;"
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_bind_int( stmt[0], 1, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_id)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE && rc != SQLITE_ROW ) ERROR_ZOND_DBASE( "sqlite3_step" )

    if ( rc == SQLITE_ROW ) first_child_id =
            sqlite3_column_int( stmt[0], 1 );

    if ( rc == SQLITE_DONE ) ERROR_S_MESSAGE_VAL( "node_id existiert nicht", -2 )

    return first_child_id;
}


gint
zond_dbase_get_root_id( ZondDBase* zond_dbase, gint node_id, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
        //...
            "WITH RECURSIVE cte_labels (node_id) AS ( "
                "VALUES (@1) "
                "UNION ALL "
                "SELECT baum.node_id "
                    "FROM baum JOIN cte_labels WHERE "
                    "baum.parent_id = cte_labels.node_id "
                ") SELECT node_id AS ID_CTE FROM cte_labels WHERE node_id<>0; "
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_bind_int( stmt[0], 1, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_id)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE && rc != SQLITE_ROW ) ERROR_ZOND_DBASE( "sqlite3_step" )

    if ( rc == SQLITE_DONE ) return 0; //entweder node_id gar nicht vorhanden oder wurzelt nicht in root 0

    return sqlite3_column_int( stmt[0], 0 );
}


//0 - keine Fundstelle
//1 - nur Datei
//2 - Datei mit Anbindung
gint
zond_dbase_get_fundstelle( ZondDBase* zond_dbase, gint node_id, gint* fundstelle_ID,
        gchar** rel_path, Anbindung* anbindung, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
        //...
            "SELECT ID, rel_path, par1, par2, par3, par4 FROM "
                "fundstelle "
                "JOIN "
                "baum "
                "WHERE baum.node_id=?1 AND baum.type=1 AND baum.ref=fundstelle.ID;"
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_bind_int( stmt[0], 1, node_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (node_id)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE && rc != SQLITE_ROW ) ERROR_ZOND_DBASE( "sqlite3_step" )

    if ( rc == SQLITE_ROW )
    {
        if ( fundstelle_ID ) *fundstelle_ID = sqlite3_column_int( stmt[0], 0 );
        if ( rel_path ) *rel_path = g_strdup( (const gchar*) sqlite3_column_text( stmt[0], 1 ) );
        if ( anbindung )
        {
            anbindung->von.seite = sqlite3_column_int( stmt[0], 2 );
            anbindung->von.index = sqlite3_column_int( stmt[0], 3 );
            anbindung->bis.seite = sqlite3_column_int( stmt[0], 4 );
            anbindung->bis.index = sqlite3_column_int( stmt[0], 5 );
        }
        if ( sqlite3_column_type( stmt[0], 2 ) == SQLITE_NULL ) return 1; //nur Datei
        else return 2; //mit Anbindung
    }

    //else rc == SQLITE_DONE:
    return 0;
}


gint
zond_dbase_test_path( ZondDBase* zond_dbase, const gchar* rel_path, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
        //...
            "SELECT ID FROM fundstelle "
                "WHERE rel_path = ?;"
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_bind_text( stmt[0], 1, rel_path, -1, NULL );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_text (rel_path)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE && rc != SQLITE_ROW ) ERROR_ZOND_DBASE( "sqlite3_step" )

    if ( rc == SQLITE_ROW ) return 1;

    return 0;
}


gint
zond_dbase_update_path( ZondDBase* zond_dbase, const gchar* source,
        const gchar* dest, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
        //...
            "UPDATE fundstelle SET rel_path=?1 "
                "WHERE rel_path=?2;"
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_bind_text( stmt[0], 1, dest, -1, NULL );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_text (dest)" )

    rc = sqlite3_bind_text( stmt[0], 2, source, -1, NULL );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_text (source)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step" )

    return 0;
}


gint
zond_dbase_insert_fundstelle( ZondDBase* zond_dbase, const gchar* rel_path,
        const Anbindung* anbindung, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
        //...
            "INSERT INTO fundstelle (rel_path, par1, par2, par3, par4) "
                "VALUES (?1,?2,?3,?4,?5);",

            "VALUES (last_insert_rowid()); "

        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_bind_text( stmt[0], 1, rel_path, -1, NULL );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_text (rel_path)" )

    if ( anbindung )
    {
        rc = sqlite3_bind_int( stmt[0], 2, anbindung->von.seite );
        if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (von.seite)" )

        rc = sqlite3_bind_int( stmt[0], 3, anbindung->von.index );
        if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (von.index)" )

        rc = sqlite3_bind_int( stmt[0], 4, anbindung->bis.seite );
        if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (bis.seite)" )

        rc = sqlite3_bind_int( stmt[0], 5, anbindung->bis.index);
        if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (bis-index)" )
    }
    else
    {
        rc = sqlite3_bind_null( stmt[0], 2 );
        if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_null (par1)" )

        rc = sqlite3_bind_null( stmt[0], 3 );
        if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_null (par2)" )

        rc = sqlite3_bind_null( stmt[0], 4 );
        if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_null (par3)" )

        rc = sqlite3_bind_null( stmt[0], 5 );
        if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_null (par4)" )
    }

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step" )

    rc = sqlite3_step( stmt[1] );
    if ( rc != SQLITE_ROW ) ERROR_ZOND_DBASE( "sqlite3_step (2)" )

    return sqlite3_column_int( stmt[1], 0 );
}


//gint Anzahl der fundstellen für rel_path zurück
//Bei Fehler: -1
gint
zond_dbase_get_fundstellen_for_rel_path( ZondDBase* zond_dbase, const gchar* rel_path,
        GArray** arr_fundstellen, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;
    gint zaehler = 0;

    const gchar* sql[] = {
        //...
            "SELECT ID, par1, par2, par3, par4 FROM fundstelle "
                "WHERE rel_path=?1; "
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_bind_text( stmt[0], 1, rel_path, -1, NULL );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_text (rel_path)" )

    if ( arr_fundstellen ) *arr_fundstellen = g_array_new( FALSE, FALSE, sizeof( Fundstelle ) );

    do
    {
        rc = sqlite3_step( stmt[0] );
        if ( rc != SQLITE_ROW && rc != SQLITE_DONE )
        {
            if ( arr_fundstellen )
            {
                g_array_unref( *arr_fundstellen );
                *arr_fundstellen = NULL;
            }
            ERROR_ZOND_DBASE( "sqlite3_step" )
        }
        else if ( rc == SQLITE_ROW )
        {
            Fundstelle fundstelle = { 0 };

            fundstelle.fundstelle_id = sqlite3_column_int( stmt[0], 0 );

            if ( arr_fundstellen )
            {
                if ( sqlite3_column_type( stmt[0], 1 ) != SQLITE_NULL )
                {
                    fundstelle.anbindung.von.seite = sqlite3_column_int( stmt[0], 1 );
                    fundstelle.anbindung.von.index = sqlite3_column_int( stmt[0], 2 );
                    fundstelle.anbindung.bis.seite = sqlite3_column_int( stmt[0], 3 );
                    fundstelle.anbindung.bis.index = sqlite3_column_int( stmt[0], 4 );
                }
                else fundstelle.anbindung.von.seite = -1;

                g_array_append_val( *arr_fundstellen, fundstelle );
            }
            zaehler++;
        }
    } while ( rc == SQLITE_ROW );

    return zaehler;
}


gint
zond_dbase_fundstelle_get_number_refs( ZondDBase* zond_dbase, gint fundstelle_id,
        gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
        //...
            "SELECT COUNT(node_id) FROM baum "
                "WHERE ref=?1 AND type=1;"
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_bind_int( stmt[0], 1, fundstelle_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (fundstelle_id)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE && rc != SQLITE_ROW ) ERROR_ZOND_DBASE( "sqlite3_step" )

    return sqlite3_column_int( stmt[0], 0 );
}


gint
zond_dbase_remove_fundstelle( ZondDBase* zond_dbase, gint fundstelle_id, gchar** errmsg )
{
    gint rc = 0;
    sqlite3_stmt** stmt = NULL;

    const gchar* sql[] = {
        //...
            "DELETE FROM fundstelle"
                "WHERE ID=?1;"
        };

    rc = zond_dbase_prepare( zond_dbase, __func__, sql, nelem( sql ), &stmt, errmsg );
    if ( rc ) ERROR_S

    rc = sqlite3_bind_int( stmt[0], 1, fundstelle_id );
    if ( rc != SQLITE_OK ) ERROR_ZOND_DBASE( "sqlite3_bind_int (fundstelle_id)" )

    rc = sqlite3_step( stmt[0] );
    if ( rc != SQLITE_DONE ) ERROR_ZOND_DBASE( "sqlite3_step" )

    return 0;
}


gint
zond_dbase_walk_tree( ZondDBase* zond_dbase, gint root_id, gint* ebene,
        ZondDBaseWalkTreeForeachFunc foreach, gpointer data, gchar** errmsg )
{
    gint rc = 0;
    gint first_child_id = 0;

    rc = foreach( root_id, ebene, data, errmsg );
    if ( rc == -1 ) ERROR_S
    else if ( rc == 1 ) return 1;

    //Prüfen, ob Kind- oder Geschwisterknoten vorhanden
    first_child_id = zond_dbase_get_first_child( zond_dbase, root_id, errmsg );
    if ( first_child_id < 0 ) ERROR_S
    else if ( first_child_id > 0 )
    {
        gint node_id = 0;

        if ( ebene ) (*ebene)++;
        node_id = first_child_id;

        do
        {
            gint younger_sibling_id = 0;

            rc = zond_dbase_walk_tree( zond_dbase, node_id, ebene, foreach, data, errmsg );
            if ( rc == -1 ) ERROR_S
            else if ( rc == 1 ) return 1;

            younger_sibling_id = zond_dbase_get_younger_sibling( zond_dbase, node_id, errmsg );
            if ( younger_sibling_id < 0 ) ERROR_S

            node_id = younger_sibling_id;
        } while ( node_id );

        if ( ebene ) (*ebene)--;
    }

    return 0;
}


